\subsection{Oracles}
\begin{theorem}
    There exists an oracle $\mathcal{O}$ relative to which $\textbf{P}^{\mathcal{O}} = \textbf{NP}^{\mathcal{O}}$
\end{theorem}
\begin{proof}
    The idea here is to note that \textbf{P} and \textbf{NP} are subsets of \textbf{PSPACE}, a class who, from it's perspective, can't tell a difference between determinism and nondeterminism! Let $\mathcal{O} = QSAT$, so that $\textbf{P}^{\mathcal{O}} = \textbf{P}^{\textbf{PSPACE}}$. Clearly \textbf{PSPACE} itself is contained in this class, as any problem within it can now be solved in a single step. Just as clear is that \textbf{P}$^{PSPACE} \subseteq \textbf{NP}^{PSPACE}$. Slightly less trivial is that $\textbf{NP}^{\textbf{PSPACE}} \subseteq \textbf{NPSPACE}$. The reason for this inclusion is that any computation in the former class can be simulated by simply taking away the oracle, and replacing it with an actual polynomial space deterministic computation. This computation is still, however, done in polynomial space, so the inclusion holds. Finally, by Savitch's theorem, since \textbf{NPSPACE} $\subseteq$ \textbf{PSPACE}, we see that
    \begin{align}
        \textbf{PSPACE} \subseteq \textbf{P}^{\textbf{PSPACE}} \subseteq \textbf{NP}^{\textbf{PSPACE}} \subseteq \textbf{NPSPACE} \subseteq \textbf{PSPACE}
    \end{align}
    Thus, $\textbf{P}^{\textbf{PSPACE}} = \textbf{NP}^{\textbf{PSPACE}}$
\end{proof}
\begin{theorem}
    There exists an oracle $\mathcal{O}$ relative to which \textbf{P$^{\mathcal{O}}$} $\neq$ \textbf{NP}$^{\mathcal{O}}$ 
\end{theorem}
\begin{proof}
    To construct our language $\mathcal{O}$ we will carefully run along the diagonal made up of an enumeration of all Turing machines with oracle versus inputs to those machines, occasionally adding strings to $\mathcal{O}$ in order to ensure the existence of a language with the desired properties. We must be very careful as we go, because we will be constructing our language by simulating Turing machines with an oracle for this language which we will at no point be actually finished constructing! This makes the proof a little confusing at first, because we are going to be acting as if we already have $\mathcal{O}$ as we go about defining it. As we go, we'll have to double back several times and take measures to ensure that what we are doing isn't total garbage. In any case, let $\{M_n^{\mathcal{O}}\}_{n=1}^\infty$ be an enumeration of all Turing machines such that every machine appears infinitely many times in the enumeration. To be more specific and convince a reader that this is reasonable: Given a Turing machine $M=(\Sigma,Q,\delta)$, if we just define $M'=(\Sigma,Q\cup \{q_n\},\delta)$, where $q_n$ is some new state which wasn't originally in $Q$, then $M'$ will behave identically to $M$ on all inputs, halting in the same amount number of steps if it halts, and returning the same results. Assume a binary alphabet for all of these machines. Now, define the unary language 
    \[U = \{1^n: \exists x \in \mathcal{O} \textrm{ such that } |x| = n \} \]
    So, assuming we had our oracle, U would represent the decision problem "Does $\mathcal{O}$ contain an x of length n?". We define $\mathcal{O}$ inductively 'in stages'. Let $X$ be a set, initially empty. Define $\mathcal{O}_0 = \varnothing$. That's the $0^{th}$ stage. Now inductively suppose $\mathcal{O}_{i-1}$ has been defined for some $i$. 
    \par First, we simulate the first $i^{log(i)}$ steps of $M_{i}^{\mathcal{O}}$, on input $1^i$. Note how we are 'running along the diagonal' in the sense that we are looking at the $i^{th}$ Turing machine on input $1^i$. We will make sure that if $M_i^{\mathcal{O}}$ is a polynomial time Turing machine, then at the very least it will disagree with U on input $1^i$. These $\mathcal{O}_i$'s are an ascending sequence of sets, and our oracle $\mathcal{O}$ will be the limit as $i$ goes to infinite of these sets. It is also worth noting now that we will only ever be adding strings of length $i$ at the $i^{th}$ stage. 
    \par Suppose that the machine wants to make a call to the oracle on some input $x$. If $|x|<i$, then it will have been added to $\mathcal{O}_{|x|}$ if it was supposed to be added, so we simply look this up. If $|x|\geq i$, then the answer will \textit{always} be no. To make sure of this, we add that string to $X$, the set of 'exceptions' - strings which we are not allowed to add to $\mathcal{O}_i$ at any later stage of the construction. For each $i$, the $i^{th}$ machine may either halt in rejection, halt in acceptance, or not halt at all, and we address these cases one at a time.
    \par Suppose $M_i^{\mathcal{O}}(1^i)$ halts in rejection within $i^{log(i)}$ steps. Then we need to make sure that this machine disagrees with $U$ by adding in a string $x$ of length $i$. The potential strings which we are allowed to add to $\mathcal{O}$ are precisely those which are not in $X$. Note that there are $2^i$ total strings of length $i$. What is the maximum number of strings which could have been added to $X$ by the end of stage $i$? In the worst case, we would have that every Turing machine simulated made a call to the oracle on a strings a string of longer length than it's input, (which is of course impossible, but this will still work as an upper bound because the reality is less oracle calls) in which case we would have added $\sum_{j=1}^{i}j^{log(j)}$ strings. We claim that for all natural numbers $i$,
    \begin{align}
        \sum_{j=1}^{i}j^{log(j)} < 2^i
    \end{align}
    A simple induction shows this to be the case. Thus, there must exist a string of length $|i|$ which is not in $X$. We choose such a string, call it $x$, and define $\mathcal{O}_i = O_{i-1} \cup \{x\}$. This ensures that $L(M_i^{\mathcal{O}}) \neq U$, and lets us be content in knowing that this addition to the oracle doesn't contradict any of the oracle calls made earlier in this construction. (If you'd rather not use countable choice, you can instead add all such $x$ of length $i$ not yet having appeared in $X$.) Note that the number of simulated steps saves us here. $i^{log(i)}$ is a sweet spot. It grows faster than any polynomial, but slower than any true exponential. Here we have exploited the 'slowness', in order to ensure that we always have strings to add. Another fairly interesting thing to note is that in order to ensure our difference was nonempty, just being smaller than an exponential wasn't good enough. We needed it to be so slow that \textit{even what is essentially it's integral} is smaller than an exponential. In other words, we needed a significant gap, not simply one of size, but of speed as well.
    \par Next suppose that $M_i^{\mathcal{O}}(1^i)$ halts in acceptance within the allotted number of steps. Then we have the much simpler task of simply not adding anything at all to our oracle. Just define $O_i = O_{i-1}$, and move to the next step.
    \par Finally, suppose that the machine fails to halt within $i^{log(i)}$ steps. Then, we again add nothing, letting $O_i = O_{i-1}$, but we have to think a bit more, as this alone is not enough to ensure that $L(M_i^{\mathcal{O}}) \neq U$, and the machine could easily still be one which halts in polynomial time. (It could just be that the polynomial bound $k$ is relatively large, and it's place in the enumeration relatively small.) The machine could still halt in polynomial time on $1^n$ in rejection, meaning it would agree on that input. Our enumeration saves us here. 
    \par Suppose the worst case scenario: That the $i^{th}$ machine halts on input $1^i$ in rejection within $O(i^k)$ steps for some integer $k$. Let $L_i = L(M_i^{\mathcal{O}})$. Earlier we exploited the 'slowness' of $i^{log(i)}$, and now we exploit the 'fastness'. Since $i^{log(i)}$ grows faster than any polynomial, there exists an integer $N$ such that for all $l \geq N$, $p(l)<l^{log(l)}$. Furthermore, by the assumption about the enumeration of Turing machines, there must exist a $l \geq N$ such that $M_l$ halts in the same number of steps as $M_i$, and such that $L_l = L_i$. Now, since $p(l) < l^{log(l)}$, there is no chance that $M_l^{\mathcal{O}}(1^l)$ will not halt, and we will be guaranteed to add an $x$ of length $l$ to $\mathcal{O}$ so that $L_l \neq U$. But of course, this ensures that $L_i \neq U$, so we have confirmed that our construction works. If there does exist an oracle Turing machine that decides $U$, it by construction cannot be one which operates in polynomial time. $U \notin \textbf{P}^{\mathcal{O}}$
    \par Finally, note that $U$ is clearly in $\textbf{NP}^{\mathcal{O}}$. A nondeterministic machine with an oracle for $\mathcal{O}$ can easily decide if $1^i \in U$, by simply guessing from among strings of length of length $i$, and consulting the oracle to determine membership. If any of the answers are yet, we have the machine halt in acceptance.
\end{proof}

